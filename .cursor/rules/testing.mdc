---
description: 
globs: tests/**/*.py
alwaysApply: false
---
1. ğŸ¯ Purpose

To ensure all tests â€” both unit and integration â€” are:

- Precise in intent
- Fully verifying the contract of the component under test
- Isolated from unrelated dependencies
- Described clearly for human readability and maintainability

This cursor rule must be followed both by human developers and any AI writing tests.

2. âœ… Scope of Tests

2.1 Unit Tests

Must test the smallest testable part of the application in isolation.

- Only one unit (e.g., function, class method) should be tested per test case.
- External dependencies (DBs, APIs, services, time, randomness, etc.) must be mocked or stubbed.

2.2 Integration Tests

Should test cooperation between units (e.g., service layer + repository).

- Can include real implementations of multiple components, but external system boundaries must still be mocked unless explicitly testing integrations.
- Only use real I/O for designated "integration" or "e2e" test environments, never in unit tests.

3. ğŸ“‹ Test Case Structure

All tests must follow this standard format:

```python
def test_<unit_of_work>__<condition>__<expected_outcome>():
    """
    Scenario:
        - Description of the test scenario in 2â€“4 lines of natural language.
        - Describe what is being tested and why it's important.

    Expected Outcome:
        - Explicitly state what the correct result should be (including side effects).
    """
    # Arrange
    # Setup necessary inputs and mocks

    # Act
    # Run the function or method being tested

    # Assert
    # Check for correct result and side effects
```  

4. ğŸ§  AI Agent Testing Rules

When AI is tasked to write tests, it must:

- Use the above structure.
- Generate a clear, natural-language docstring summarizing the scenario and expected result.
- Mock all dependencies not directly under test.
- Avoid redundant assertions or low-value "happy path only" testing â€” focus on variation in input and edge cases.
- Ensure high coverage of:
  - Control flow (if/else, error branches)
  - Contract fidelity (input/output invariants, exceptions)
  - State changes (data updates, method calls)
- Do not test third-party libraries (assume their correctness).

5. ğŸ”¬ Coverage Requirements

- All public methods and functions must be tested with 100% logical branch coverage.
- Edge cases must be included (e.g. empty list, None, 0, large inputs).
- For integration tests, ensure interface expectations between units are fully verified.
- Use pytest-cov or equivalent to enforce and review coverage.

6. ğŸ”„ Isolation Rule

- Only the unit or flow under test may contain logic.
- Everything else (e.g., repositories, downstream APIs, services, clocks, logging, randomness) must be mocked using unittest.mock, pytest-mock, or equivalent.
- Use fixtures where applicable, but avoid overly abstract or reused test setups that reduce test clarity.

7. ğŸ·ï¸ Naming & File Structure

Test files mirror the code structure: foo.py â†’ test_foo.py

Use descriptive function names:

- âœ… test_user_creation__invalid_email__raises_error
- âŒ test_invalid_email

8. ğŸ“š Example

```python
def test_calculate_discount__vip_customer__applies_20_percent():
    """
    Scenario:
        A VIP customer is eligible for a 20% discount. We want to verify that
        the discount logic applies the correct rate based on the customer tier.

    Expected Outcome:
        The function should return the original price multiplied by 0.8.
    """
    # Arrange
    price = 100.0
    customer = Customer(tier="VIP")

    # Act
    result = calculate_discount(price, customer)

    # Assert
    assert result == 80.0
```  

9. ğŸ§µ Integration Test Example

```python
def test_user_registration_flow__valid_data__creates_user_and_sends_email():
    """
    Scenario:
        A new user registers with valid data. The service should create the user,
        send a welcome email, and return a success status.

    Expected Outcome:
        - UserRepository.save is called with correct user
        - EmailService.send_welcome_email is called
        - Function returns success result
    """
    # Arrange
    user_data = {"email": "test@example.com", "name": "Alice"}
    repo = Mock()
    email_service = Mock()
    service = UserService(repo, email_service)

    # Act
    result = service.register_user(user_data)

    # Assert
    repo.save.assert_called_once()
    email_service.send_welcome_email.assert_called_once()
    assert result == {"status": "ok"}
```

